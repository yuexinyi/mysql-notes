6. 表的增删改查
CRUD : Create, Retrieve，Update，Delete
6.1 Create
语法：
案例：
6.1.1 单行数据 + 全列插入
6.1.2 多行数据 + 指定列插入
INSERT [INTO] table_name
[(column [, column] ...)]
VALUES (value_list) [, (value_list)] ...
value_list: value, [, value] ...
-- 创建一张学生表
CREATE TABLE students (
 id INT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
 sn INT NOT NULL UNIQUE COMMENT '学号',
 name VARCHAR(20) NOT NULL,
 qq VARCHAR(20)
);
-- 插入两条记录，value_list 数量必须和定义表的列的数量及顺序一致
INSERT INTO students VALUES (100, 10000, '唐三藏', NULL);
Query OK, 1 row affected (0.02 sec)
INSERT INTO students VALUES (101, 10001, '孙悟空', '11111');
Query OK, 1 row affected (0.02 sec)
-- 查看插入结果
SELECT * FROM students;
+-----+-------+-----------+-------+
| id | sn  | name   | qq  |
+-----+-------+-----------+-------+
| 100 | 10000 | 唐三藏   | NULL |
| 101 | 10001 | 孙悟空   | 11111 |
+-----+-------+-----------+-------+
2 rows in set (0.00 sec)
-- 插入两条记录，value_list 数量必须和指定列数量及顺序一致
6.1.3 插入否则更新
由于 主键 或者 唯一键 对应的值已经存在而导致插入失败
可以选择性的进行同步更新操作 语法：
INSERT INTO students (id, sn, name) VALUES
(102, 20001, '曹孟德'),
(103, 20002, '孙仲谋');
Query OK, 2 rows affected (0.02 sec)
Records: 2 Duplicates: 0  Warnings: 0
-- 查看插入结果
SELECT * FROM students;
+-----+-------+-----------+-------+
| id | sn  | name   | qq  |
+-----+-------+-----------+-------+
| 100 | 10000 | 唐三藏   | NULL |
| 101 | 10001 | 孙悟空   | 11111 |
| 102 | 20001 | 曹孟德   | NULL |
| 103 | 20002 | 孙仲谋   | NULL |
+-----+-------+-----------+-------+
4 rows in set (0.00 sec)
-- 主键冲突
INSERT INTO students (id, sn, name) VALUES (100, 10010, '唐大师');
ERROR 1062 (23000): Duplicate entry '100' for key 'PRIMARY'
-- 唯一键冲突
INSERT INTO students (sn, name) VALUES (20001, '曹阿瞒');
ERROR 1062 (23000): Duplicate entry '20001' for key 'sn'
INSERT ... ON DUPLICATE KEY UPDATE
column = value [, column = value] ...
INSERT INTO students (id, sn, name) VALUES (100, 10010, '唐大师')
ON DUPLICATE KEY UPDATE sn = 10010, name = '唐大师';
Query OK, 2 rows affected (0.47 sec)
-- 0 row affected: 表中有冲突数据，但冲突数据的值和 update 的值相等
-- 1 row affected: 表中没有冲突数据，数据被插入
-- 2 row affected: 表中有冲突数据，并且数据已经被更新
-- 通过 MySQL 函数获取受到影响的数据行数
SELECT ROW_COUNT();
+-------------+
| ROW_COUNT() |
+-------------+
|      2 |
+-------------+
1 row in set (0.00 sec)
6.1.4 替换
6.2 Retrieve
语法：
案例：
6.2.1 SELECT 列
6.2.1.1 全列查询
-- 主键 或者 唯一键 没有冲突，则直接插入；
-- 主键 或者 唯一键 如果冲突，则删除后再插入
REPLACE INTO students (sn, name) VALUES (20001, '曹阿瞒');
Query OK, 2 rows affected (0.00 sec)
-- 1 row affected: 表中没有冲突数据，数据被插入
-- 2 row affected: 表中有冲突数据，删除后重新插入
SELECT
[DISTINCT] {* | {column [, column] ...}
[FROM table_name]
[WHERE ...]
[ORDER BY column [ASC | DESC], ...]
LIMIT ...
-- 创建表结构
CREATE TABLE exam_result (
id INT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
name VARCHAR(20) NOT NULL COMMENT '同学姓名',
yuwen float DEFAULT 0.0 COMMENT '语文成绩',
shuxue float DEFAULT 0.0 COMMENT '数学成绩',
yingyu float DEFAULT 0.0 COMMENT '英语成绩'
);
-- 插入测试数据
INSERT INTO exam_result (name, yuwen, shuxue, yingyu) VALUES
('唐三藏', 67, 98, 56),
('孙悟空', 87, 78, 77),
('猪悟能', 88, 98, 90),
('曹孟德', 82, 84, 67),
('刘玄德', 55, 85, 45),
('孙权', 70, 73, 78),
('宋公明', 75, 65, 30);
Query OK, 7 rows affected (0.00 sec)
Records: 7 Duplicates: 0  Warnings: 0
-- 通常情况下不建议使用 * 进行全列查询
-- 1. 查询的列越多，意味着需要传输的数据量越大；
6.2.1.2 指定列查询
6.2.1.3 查询字段为表达式
-- 2. 可能会影响到索引的使用。（索引待后面课程讲解）
SELECT * FROM exam_result;
+----+-----------+-------+--------+--------+
| id | name   | yuwen | shuxue | yingyu |
+----+-----------+-------+--------+--------+
|  1 | 唐三藏   |   67 |   98 |   56 |
|  2 | 孙悟空   |   87 |   78 |   77 |
|  3 | 猪悟能   |   88 |   98 |   90 |
|  4 | 曹孟德   |   82 |   84 |   67 |
|  5 | 刘玄德   |   55 |   85 |   45 |
|  6 | 孙权    |   70 |   73 |   78 |
|  7 | 宋公明   |   75 |   65 |   30 |
+----+-----------+-------+--------+--------+
7 rows in set (0.00 sec)
-- 指定列的顺序不需要按定义表的顺序来
SELECT id, name, yingyu FROM exam_result;
+----+-----------+--------+
| id | name   | yingyu |
+----+-----------+--------+
|  1 | 唐三藏   |   56 |
|  2 | 孙悟空   |   77 |
|  3 | 猪悟能   |   90 |
|  4 | 曹孟德   |   67 |
|  5 | 刘玄德   |   45 |
|  6 | 孙权    |   78 |
|  7 | 宋公明   |   30 |
+----+-----------+--------+
7 rows in set (0.00 sec)
-- 表达式不包含字段
SELECT id, name, 10 FROM exam_result;
+----+-----------+----+
| id | name   | 10 |
+----+-----------+----+
|  1 | 唐三藏   | 10 |
|  2 | 孙悟空   | 10 |
|  3 | 猪悟能   | 10 |
|  4 | 曹孟德   | 10 |
|  5 | 刘玄德   | 10 |
|  6 | 孙权    | 10 |
|  7 | 宋公明   | 10 |
+----+-----------+----+
7 rows in set (0.00 sec)
6.2.1.4 为查询结果指定别名
语法：
-- 表达式包含一个字段
SELECT id, name, yingyu + 10 FROM exam_result;
+----+-----------+-------------+
| id | name   | yingyu + 10 |
+----+-----------+-------------+
|  1 | 唐三藏   |      66 |
|  2 | 孙悟空   |      87 |
|  3 | 猪悟能   |     100 |
|  4 | 曹孟德   |      77 |
|  5 | 刘玄德   |      55 |
|  6 | 孙权    |      88 |
|  7 | 宋公明   |      40 |
+----+-----------+-------------+
7 rows in set (0.00 sec)
-- 表达式包含多个字段
SELECT id, name, yuwen + shuxue + yingyu FROM exam_result;
+----+-----------+-------------------------+
| id | name   | yuwen + shuxue + yingyu |
+----+-----------+-------------------------+
|  1 | 唐三藏   |           221 |
|  2 | 孙悟空   |           242 |
|  3 | 猪悟能   |           276 |
|  4 | 曹孟德   |           233 |
|  5 | 刘玄德   |           185 |
|  6 | 孙权    |           221 |
|  7 | 宋公明   |           170 |
+----+-----------+-------------------------+
7 rows in set (0.00 sec)
SELECT column [AS] alias_name [...] FROM table_name;
SELECT id, name, yuwen + shuxue + yingyu 总分 FROM exam_result;
+----+-----------+--------+
| id | name   | 总分  |
+----+-----------+--------+
|  1 | 唐三藏   |   221 |
|  2 | 孙悟空   |   242 |
|  3 | 猪悟能   |   276 |
|  4 | 曹孟德   |   233 |
|  5 | 刘玄德   |   185 |
|  6 | 孙权    |   221 |
|  7 | 宋公明   |   170 |
+----+-----------+--------+
7 rows in set (0.00 sec)
6.2.1.5 结果去重
6.2.2 WHERE 条件
比较运算符：
-- 98 分重复了
SELECT shuxue FROM exam_result;
+--------+
| shuxue |
+--------+
|   98 |
|   78 |
|   98 |
|   84 |
|   85 |
|   73 |
|   65 |
+--------+
7 rows in set (0.00 sec)
-- 去重结果
SELECT DISTINCT shuxue FROM exam_result;
+--------+
| shuxue |
+--------+
|   98 |
|   78 |
|   84 |
|   85 |
|   73 |
|   65 |
+--------+
6 rows in set (0.00 sec)